---
permalink: /sw.js
# Jekyll will process this file
---

// Import Workbox
importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.3.0/workbox-sw.js');

const DEBUG = {% if jekyll.environment == "development" %}true{% else %}false{% endif %};

if (workbox) {
  if (DEBUG) console.log('Workbox loaded successfully');

  // Configure Workbox with modern settings
  workbox.setConfig({
    debug: DEBUG,
    modulePathPrefix: 'https://storage.googleapis.com/workbox-cdn/releases/7.3.0/'
  });

  // Set up custom cache name with versioning
  workbox.core.setCacheNameDetails({
    prefix: 'pxo-pulse',
    suffix: '{% cache_bust_param %}',
    precache: 'precache-v1',
    runtime: 'runtime-v1'
  });

  // Precache essential files with proper revision handling
  const precacheManifest = DEBUG ? [
    { url: '/offline.html', revision: '{% cache_bust_param %}' }
  ] : [
    { url: '/', revision: '{% cache_bust_param %}' },
    { url: '/offline.html', revision: '{% cache_bust_param %}' },
    { url: '/assets/site.webmanifest', revision: '{% cache_bust_param %}' },
    { url: '/assets/css/styles.css', revision: '{% cache_bust_param %}' }
  ];

  // Enable navigation preload for better performance
  workbox.navigationPreload.enable();

  workbox.precaching.precacheAndRoute(precacheManifest);

  // Set up offline fallback page reference
  const FALLBACK_HTML_URL = '/offline.html';

  // Simplified debug mode strategy
  if (DEBUG) {
    // In debug mode, use NetworkOnly to always get fresh content
    workbox.routing.setDefaultHandler(
      new workbox.strategies.NetworkOnly({
        plugins: [
          {
            handlerDidError: async () => {
              return caches.match(FALLBACK_HTML_URL);
            }
          }
        ]
      })
    );
  } else {
    // Production strategies with modern best practices

    // Stale While Revalidate for HTML pages (better UX than NetworkFirst)
    workbox.routing.registerRoute(
      ({ request }) => request.mode === 'navigate',
      new workbox.strategies.StaleWhileRevalidate({
        cacheName: 'pages-cache-v1',
        plugins: [
          new workbox.cacheableResponse.CacheableResponsePlugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.ExpirationPlugin({
            maxEntries: 50,
            maxAgeSeconds: 24 * 60 * 60, // 24 hours
            purgeOnQuotaError: true
          })
        ]
      })
    );

    // Cache First for static assets with longer expiration
    workbox.routing.registerRoute(
      ({ request, url }) => {
        return url.pathname.startsWith('/assets/') ||
               request.destination === 'style' ||
               request.destination === 'script' ||
               request.destination === 'font' ||
               request.destination === 'manifest';
      },
      new workbox.strategies.CacheFirst({
        cacheName: 'static-assets-v1',
        plugins: [
          new workbox.cacheableResponse.CacheableResponsePlugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.ExpirationPlugin({
            maxEntries: 100,
            maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
            purgeOnQuotaError: true
          })
        ]
      })
    );

    // Cache First for images with compression awareness
    workbox.routing.registerRoute(
      ({ request }) => request.destination === 'image',
      new workbox.strategies.CacheFirst({
        cacheName: 'images-cache-v1',
        plugins: [
          new workbox.cacheableResponse.CacheableResponsePlugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.ExpirationPlugin({
            maxEntries: 60,
            maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
            purgeOnQuotaError: true
          })
        ]
      })
    );

    // Network First for API calls and other dynamic content
    workbox.routing.setDefaultHandler(
      new workbox.strategies.NetworkFirst({
        cacheName: 'api-cache-v1',
        networkTimeoutSeconds: 3,
        plugins: [
          new workbox.cacheableResponse.CacheableResponsePlugin({
            statuses: [0, 200]
          }),
          new workbox.expiration.ExpirationPlugin({
            maxEntries: 50,
            maxAgeSeconds: 5 * 60, // 5 minutes
            purgeOnQuotaError: true
          })
        ]
      })
    );
  }

  // Enhanced offline fallback with better error handling
  workbox.routing.setCatchHandler(({ event }) => {
    const { request } = event;

    // Return offline page for navigation requests
    if (request.mode === 'navigate') {
      return workbox.precaching.matchPrecache(FALLBACK_HTML_URL);
    }

    // Return offline image for image requests
    if (request.destination === 'image') {
      return new Response(
        '<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200"><rect width="200" height="200" fill="#f3f4f6"/><text x="100" y="100" text-anchor="middle" dy=".3em" fill="#9ca3af" font-family="sans-serif" font-size="14">Imagem não disponível</text></svg>',
        {
          status: 200,
          statusText: 'OK',
          headers: {
            'Content-Type': 'image/svg+xml',
            'Cache-Control': 'no-cache'
          }
        }
      );
    }

    // Return generic error for other requests
    return Response.error();
  });

  // Handle install and activate lifecycle events
  self.addEventListener('install', () => {
    self.skipWaiting();
  });

  self.addEventListener('activate', (event) => {
    event.waitUntil(self.clients.claim());
  });

} else {
  console.error('Workbox could not be loaded. Falling back to basic implementation.');

  // Basic fallback implementation if Workbox fails to load
  const CACHE_NAME = 'pxo-pulse-{% cache_bust_param %}-fallback';

  self.addEventListener('install', (event) => {
    self.skipWaiting();
    event.waitUntil(
      caches.open(CACHE_NAME).then((cache) => {
        return cache.addAll(['/offline.html']);
      })
    );
  });

  self.addEventListener('fetch', (event) => {
    if (event.request.mode === 'navigate') {
      event.respondWith(
        fetch(event.request).catch(() => {
          return caches.match('/offline.html');
        })
      );
    }
  });

  self.addEventListener('activate', (event) => {
    event.waitUntil(self.clients.claim());
  });
}
