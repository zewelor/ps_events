#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require_relative "../lib/ps_events/generator"
require "optparse"
require "httpx"

class Generator
  DEFAULT_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTzDO4xR7fFMB53s98OETbwFNzhiMJ7N2I-kroaNQt4iB3mUthr7z1wGj3NhRXpVi8MQDzFKB0UjY9G/pub?gid=0&single=true&output=csv"

  attr_reader :skipped

  def self.generate(url: nil)
    new(url:).generate
  end

  # Initialize with a URL or use the default
  # @param url [String] The URL to fetch the CSV from
  # @return [Generator] The generator instance

  def initialize(url: nil)
    @url = url || DEFAULT_CSV_URL
    @skipped = false
  end

  # Fetch CSV, parse events, and return an ICS string
  def generate
    response = HTTPX.plugin(:follow_redirects)
      .with(follow_insecure_redirects: false, max_redirects: 4)
      .get(@url)
    # puts "Fetching CSV from #{@url}"
    # puts response
    # exit
    csv_text = response.to_s
    events = CSV.parse(csv_text, headers: true)

    cal = Icalendar::Calendar.new
    events.each do |row|
      ev = Icalendar::Event.new
      # parse and validate start/end times
      start_time = Time.parse(row.fetch("Start time"))
      end_time = Time.parse(row.fetch("End time"))
      if end_time < start_time
        warn "Skipping event '#{row["Activity"]}' because end time #{end_time} is before start time #{start_time}"
        @skipped = true
        next
      end
      ev.dtstart = start_time
      ev.dtend = end_time
      ev.summary = row.fetch("Activity").to_s.strip
      ev.location = row["Location"].to_s.strip unless row["Location"].to_s.strip.empty?
      ev.description = row["Description"].to_s.strip unless row["Description"].to_s.strip.empty?
      ev.organizer = row["Organizer"].to_s.strip unless row["Organizer"].to_s.strip.empty?
      cal.add_event(ev)
    end

    cal.publish
    cal.to_ical
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: spreadsheet_to_ical [options] [url]"
  opts.on("-oFILE", "--output=FILE", "Write output to FILE instead of stdout") do |file|
    options[:output] = file
  end
  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end.parse!

generator = Generator.new(url: options[:url])
ics_content = generator.generate

if options[:output]
  File.write(options[:output], ics_content)
else
  puts ics_content
end

exit(1) if generator.skipped
