---
permalink: /sw.js
# Jekyll will process this file
---
const CACHE_NAME = 'pxo-pulse-{{ site.env.COMMIT_SHA | default: (site.time | date: "%Y%m%d%H%M%S") }}'; // Versioned by Git SHA or build time
const DEBUG = {% if jekyll.environment == "development" %}true{% else %}false{% endif %};

const urlsToCache = [
  '/', // Main entry point
  '/offline.html', // Essential for offline fallback
  '/assets/site.webmanifest', // Essential for PWA behavior
  '/assets/css/styles.css', // Main stylesheet, often needed for offline.html
  // Other assets like JS, images, and icons will be cached dynamically on first use.
];

// Helper function for Cache-First strategy (for assets and offline.html)
const handleCacheFirstStrategy = (request, requestUrl) => {
  return caches.match(request, { ignoreSearch: requestUrl.pathname === '/assets/css/styles.css' })
    .then((cachedResponse) => {
      if (cachedResponse) {
        if (DEBUG) console.log('Serving from cache (cache-first):', request.url);
        return cachedResponse;
      }
      if (DEBUG) console.log('Not in cache, fetching from network (cache-first):', request.url);
      return fetch(request).then((networkResponse) => {
        // Cache the new asset if fetched successfully
        if (networkResponse && networkResponse.status === 200) {
          const responseToCache = networkResponse.clone();
          // Chain the caching operation
          return caches.open(CACHE_NAME).then((cache) => {
            return cache.put(request, responseToCache)
              .then(() => {
                if (DEBUG) console.log('Cached new asset (cache-first):', request.url);
                return networkResponse; // Return response AFTER caching attempt
              })
              .catch(cacheError => {
                // Log caching error but still return the network response
                if (DEBUG) console.error('Failed to cache asset (cache-first):', request.url, cacheError);
                return networkResponse;
              });
          });
        }
        return networkResponse; // Return non-200 responses or if networkResponse is null
      });
    })
    .catch((error) => {
      if (DEBUG) console.error('Cache-first fetch failed for:', request.url, 'Error:', error);
      // For navigation requests or if offline.html itself fails, fall back to cached offline.html
      if (request.mode === 'navigate' || requestUrl.pathname === '/offline.html') {
        if (DEBUG) console.log('Returning offline.html for navigation/offline page request (cache-first error).');
        return caches.match('/offline.html');
      }
      // For other asset requests, return a generic error
      return new Response('Asset not available', { status: 404, statusText: 'Not Found' });
    });
};

// Helper function for Network-First strategy (for other requests)
const handleNetworkFirstStrategy = (request, requestUrl) => {
  return fetch(request)
    .then((networkResponse) => {
      if (DEBUG) console.log('Serving from network (network-first):', request.url);
      // Cache the new page if fetched successfully (request.method is already confirmed to be GET)
      if (networkResponse && networkResponse.status === 200) {
        const responseToCache = networkResponse.clone();
        // Chain the caching operation
        return caches.open(CACHE_NAME).then((cache) => {
          return cache.put(request, responseToCache)
            .then(() => {
              if (DEBUG) console.log('Cached new page (network-first):', request.url);
              return networkResponse; // Return response AFTER caching attempt
            })
            .catch(cacheError => {
              // Log caching error but still return the network response
              if (DEBUG) console.error('Failed to cache page (network-first):', request.url, cacheError);
              return networkResponse;
            });
        });
      }
      return networkResponse; // Return non-200 responses or if networkResponse is null
    })
    .catch((error) => {
      if (DEBUG) console.warn('Network request failed, trying cache (network-first):', request.url, 'Error:', error);
      return caches.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          if (DEBUG) console.log('Serving from cache (network-first fallback):', request.url);
          return cachedResponse;
        }
        // If not in cache and network failed, for navigation, show offline page
        if (request.mode === 'navigate') {
          if (DEBUG) console.log('Returning offline.html for navigation request (network-first error and no cache).');
          return caches.match('/offline.html');
        }
        // For other requests, return a generic error
        if (DEBUG) console.error('Failed to fetch from network and not in cache (network-first):', request.url);
        return new Response('Service Unavailable. Please check your internet connection.', { status: 503, statusText: 'Service Unavailable' });
      });
    });
};

// Install Service Worker
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        if (DEBUG) console.log('Opened cache and caching urls:', urlsToCache);
        return cache.addAll(urlsToCache); // This returns a promise
      })
      .then(() => {
        if (DEBUG) console.log('All URLs cached successfully during install.');
      })
      .catch(err => {
        if (DEBUG) console.error('Failed to cache one or more URLs during install:', err, urlsToCache);
        // Re-throw the error to ensure the SW install fails and retries if caching is incomplete
        throw err;
      })
  );
});

// Fetch event - serve from cache when offline
self.addEventListener('fetch', (event) => {
  const request = event.request;
  const requestUrl = new URL(request.url);

  // Skip non-GET requests and chrome-extension:// requests
  if (request.method !== 'GET' || requestUrl.protocol === 'chrome-extension:') {
    if (DEBUG) console.log('Skipping fetch event for non-GET or chrome-extension request:', request.url);
    return;
  }

  // Strategy:
  // - Cache first for /assets/* and /offline.html
  // - Network first for everything else
  if (requestUrl.pathname.startsWith('/assets/') || requestUrl.pathname === '/offline.html') {
    event.respondWith(handleCacheFirstStrategy(request, requestUrl));
  } else {
    event.respondWith(handleNetworkFirstStrategy(request, requestUrl));
  }
});

// Activate Service Worker and clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            if (DEBUG) console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  return self.clients.claim(); // Ensure new SW takes control immediately
});
