name: PR Preview

on:
  pull_request:
    paths:
      - 'events.csv'
      - '.github/workflows/pr_preview.yml'
      - 'events_listing/**'

permissions:
  contents: read
  pull-requests: write # Required for commenting on the PR
  packages: read       # For docker login to ghcr.io

jobs:
  build-and-screenshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Jekyll site with Docker Compose
        run: |
          # Ensure the _site directory exists on the host for volume mapping
          mkdir -p _site
          # Run docker compose, mounting the host's _site directory to the container's /app/_site
          # This way, the jekyll build output inside the container is written directly to the host's _site
          docker compose --file docker-compose.ci.yml run --rm \
            -e JEKYLL_ENV=production \
            -v "$(pwd)/_site:/app/_site" \
            app jekyll build --source /app/events_listing --destination /app/_site
        # No need for 'env: COMPOSE_FILE' here, as it's specified with --file

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm' # Cache npm dependencies for faster subsequent runs

      - name: Install Node.js dependencies (Playwright, http-server)
        run: |
          # Create a minimal package.json if it doesn't exist, to track dependencies
          npm init -y
          npm install playwright http-server
          # Install Playwright browsers and their OS dependencies
          npx playwright install --with-deps chromium

      - name: Start http-server in background
        run: npx http-server _site -p 8080 & # Serve the _site directory populated by Docker

      - name: Wait for server to be ready
        run: |
          echo "Waiting for server to start..."
          timeout 30s bash -c 'until curl -s -f -o /dev/null http://localhost:8080; do echo -n "." && sleep 1; done'
          echo "Server is up!"

      - name: Create screenshots directory
        run: mkdir -p screenshots

      - name: Take screenshots with Playwright
        id: screenshots # Give this step an id to potentially use its output later
        run: |
          cat > screenshot.js << 'EOL'
          const { chromium } = require('playwright');
          const fs = require('fs');

          (async () => {
            const browser = await chromium.launch({
              args: ['--no-sandbox', '--disable-setuid-sandbox'] // Recommended for CI environments
            });
            const context = await browser.newContext({
              viewport: { width: 1280, height: 720 },
              baseURL: 'http://localhost:8080', // Set base URL for easier navigation
              ignoreHTTPSErrors: true // Useful if your local server is http
            });

            const screenshotsTaken = [];
            const pagesToScreenshot = [
              { name: 'homepage', path: '/', fullPage: true },
              { name: 'events', path: '/events/', fullPage: true },
              { name: 'add_event', path: '/add_event/', fullPage: true }
            ];

            for (const pageInfo of pagesToScreenshot) {
              const page = await context.newPage();
              try {
                console.log(`Navigating to ${pageInfo.path}`);
                await page.goto(pageInfo.path, { waitUntil: 'networkidle', timeout: 20000 }); // Increased timeout
                const screenshotPath = `screenshots/${pageInfo.name}.png`;
                await page.screenshot({ path: screenshotPath, fullPage: pageInfo.fullPage });
                console.log(`Screenshot saved: ${screenshotPath}`);
                screenshotsTaken.push(pageInfo.name);
              } catch (e) {
                console.error(`Error taking screenshot for ${pageInfo.name} at ${pageInfo.path}: ${e.message}`);
                // Create an empty file as a placeholder if screenshot fails, to avoid upload errors
                // Or simply log and continue
              } finally {
                await page.close();
              }
            }
            await browser.close();
            // Output a list of successfully taken screenshots for potential use in PR comment
            console.log(`::set-output name=taken_screenshots::${screenshotsTaken.join(',')}`);
          })();
          EOL

          node screenshot.js

      - name: Upload screenshots as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pr-preview-screenshots
          path: screenshots/
          retention-days: 7 # Keep artifacts for 7 days

      - name: Comment on PR with screenshot links (or images if hosted)
        uses: marocchino/sticky-pull-request-comment@v2
        # Only run this step if the event is a pull request
        if: github.event_name == 'pull_request'
        with:
          # This will create or update a comment with a consistent header
          header: pr-preview-screenshots-comment
          message: |
            üñºÔ∏è **PR Preview Screenshots** üñºÔ∏è

            Screenshots have been generated for this Pull Request.
            You can download them as a ZIP archive from the [workflow artifacts here](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}).

            **Individual Screenshots (if uploaded and publicly accessible):**
            *(To display images directly here, they need to be uploaded to a publicly accessible URL. The links below are placeholders if you set up such a service.)*
            - Homepage: `[View Homepage Screenshot]` (link to homepage.png if hosted)
            - Events: `[View Events Screenshot]` (link to events.png if hosted)
            - Add Event: `[View Add Event Screenshot]` (link to add_event.png if hosted)

            *Successfully captured: ${{ steps.screenshots.outputs.taken_screenshots || 'None (check logs)' }}*
